{
  "author": {
    "name": "Based on jscoverage@siliconforks.com; Modified by kate.sf",
    "email": "kate.sf@taobao.com"
  },
  "name": "jscoverage",
  "description": "jscoverage module for node.js",
  "version": "0.2.5",
  "homepage": "https://github.com/sunfang1cn/node-jscoverage",
  "repository": {
    "type": "git",
    "url": "git://github.com/sunfang1cn/node-jscoverage.git"
  },
  "main": "index.js",
  "scripts": {
    "preinstall": "node-waf configure",
    "install": "node-waf"
  },
  "engines": {
    "node": ">= 0.6.0"
  },
  "dependencies": {},
  "devDependencies": {},
  "optionalDependencies": {},
  "readme": "# node-jscoverage\n\n   [JScoverage](http://siliconforks.com/jscoverage/) for node. Have been Modified to works both for binary executables and node.js modules.\n\n## Installation\n   for use in node.js modules:\n      \n      $ npm  install jscoverage\n  \n   for use by binary executables just like the source version, just pull it to local and:\n      \n      $ ./configure && make && make install\n\n## How to Use\n      /** for nodejs **/\n      var jsc = require('jscoverage');\n      require = jsc.require(module); // rewrite require function\n      // pay attention to the second param, means do jscoverage process for this module\n      var test_module = require('module for test',true); \n      \n      describe('module',function(){\n         describe('#func',function(){\n            it('some test',function(){\n               //TODO test code here\n            });\n         });\n      });\n      // output the coverage when test process exit, you can custom your own coverage report \n      // because the jscoverage report is really easy to DIY\n      process.on('exit',function(){\n         jsc.coverage();\n      });\n      \n      /** \n         for javascript in browser,you need a node server to hold your js code,\n         when browser request the js file, using jscoverage to process the file content,\n         then output the jscoverage injected code .\n      **/\n      http.create(function(req,res){\n         var path = wwwroot + req.url;\n         // process single file\n         var content = jsc.processFile(path,encode);\n         res.end(content);\n      }\n      \n   \n## API\n\n      jscoverage.processFile(path, encode): process single file, will return the process results\n         path: the file to process\n         encode: the charset of the file or content , encode: utf-8,gbk\n\n      jscoverage.process(filename, content, encode): process content input, will return the results\n         filename: this param is needed for _$jscoverage[filename], it is used as a key name.\n         content: script content,string type\n         encode: input content encode\n\n      jscoverage.processDir(source_path, dest_path, exclude, exclude_file, options): process every js file in a dir\n         source_path: the dir to process, support relative path\n         dest_path: the output dir to put result files\n         exclude: the dir to exclude, like '.svn|.git'\n         exclude_file: the file to exclude '.npmignore|.vimrc'\n         options: {}\n\n      jscoverage.require(module): automatic process when flag is true, will mock the node.js`s require\n         return the mocked require function ,which call as : \n            var mod = require(path,isInstrument);\n      jscoverage.coverage(): show coverage rate on console\n         you can custom this function to make your own coverage report!\n   \n      \n## test private functions in a module\n\n      ======== mo.js ========\n      function inner(a,b){\n         return a+b;\n      }\n      exports.mo = function(){}\n      \n      ======= test.js =======\n      var test_mo = require('./mo.js', true);\n      test_mo._test('inner',[1,2]); // test private function inner\n      var inner = test_mo._get('inner');\n      inner(1,2); // call the private inner function of the mo module \n\n## extend API \n   \n      InstrumentedMod._test(funcName,args);\n         test inner functions\n      InstrumentedMod._call(funcName,args);\n         same as _test\n      InstrumentedMod._replace(objName,value);\n         replace the inner object\n      InstrumentedMod._get(objName);\n         get the inner object;\n      InstrumentedMod._reset(objName);\n         rollback the object replace by InstrumentedMod._replace();\n      \n      jsc.config(opt);\n         you can re-defined the above extend api by call this config function\n         opt has properties:\n            call:\n            test:\n            get:\n            replace:\n            reset:\n            \n      jsc will test if your module is conflict with this inject functions , it is save!\n\n",
  "readmeFilename": "Readme.md",
  "_id": "jscoverage@0.2.5",
  "_from": "jscoverage@0.2.5"
}
